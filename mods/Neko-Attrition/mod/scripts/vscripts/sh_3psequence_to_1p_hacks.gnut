global function FirstPersonSequenceForce1P_Init
global function FirstPersonSequenceForce1P_InitPlaylistVars

#if SERVER
	global function FirstPersonSequenceForce1P
#endif

#if CLIENT
	global function ServerCallback_HideHudForFPHackAnim
#endif

global const string FORCE1P_PILOT_1P_ATTACHMENT = "HEADFOCUS"
global const string FORCE1P_TITAN_1P_ATTACHMENT = "HATCH_HEAD" // CHEST_LASER could be better, but is only on atlas titans

global const string FORCE1P_PILOT_1P_HIDDEN_BODYGROUP = "head"
global const string FORCE1P_TITAN_1P_HIDDEN_BODYGROUP = "torso"

global const string FORCE1P_PILOT_ENTITYCLASS = "npc_pilot_elite"
global const string FORCE1P_TITAN_ENTITYCLASS = "npc_titan"

global struct Forced1PSequenceData
{
	entity player
	entity camera
	entity ownerProxy
	entity thirdPersonProxy
}

void function FirstPersonSequenceForce1P_Init()
{
	// atm do this no matter what playlist we're on since playlist overrides seem to get sent to clients after networkvar registration
	// not nice but whatever lol
	AddCallback_OnRegisteringCustomNetworkVars( FirstPersonSequenceForce1P_RegisterCustomNetworkFunctions )
}

void function FirstPersonSequenceForce1P_InitPlaylistVars()
{
	AddPrivateMatchModeSettingEnum( "#MODE_SETTING_CATEGORY_RIFF", "fp_embark_enabled", [ "#SETTING_DISABLED", "#SETTING_ENABLED" ], "0" )
}

void function FirstPersonSequenceForce1P_RegisterCustomNetworkFunctions()
{
	Remote_RegisterFunction( "ServerCallback_HideHudForFPHackAnim" )
}

#if SERVER
Forced1PSequenceData function FirstPersonSequenceForce1P( FirstPersonSequenceStruct sequence, entity player, entity other = null )
{
Forced1PSequenceData cleanupData
if( player.IsPlayer() )
	{
	string attachment = FORCE1P_PILOT_1P_ATTACHMENT

	if ( player.IsTitan() )
	{
		attachment = FORCE1P_TITAN_1P_ATTACHMENT
	}
		entity camera = CreateEntity( "point_viewcontrol" )
		camera.SetParent( player, attachment )
	if( !player.IsTitan() )
	camera.SetOrigin( <6, 0, 0> )
	if( player.IsTitan() )
	{
	entity soul = player.GetTitanSoul()
	string attackerType = GetTitanCharacterName( player )
	switch ( attackerType )
	    {
		case "ronin":
		                camera.SetOrigin( <50, 0, 20> )
                        break;
		case "scorch":
                        camera.SetOrigin( <65, 0, -15> )
                        break;
		case "legion":
		                camera.SetOrigin( <65, 0, -15> )
			            break;
		case "ion":
		                camera.SetOrigin( <52, 0, -22> )
                        break;
		case "tone":
		                camera.SetOrigin( <52, 0, -22> )
                        break;
		case "vanguard":
		                camera.SetOrigin( <52, 0, -22> )
                        break;
        case "northstar":
		                camera.SetOrigin( <50, 0, 20> )
			            break;
	    }
		}
		camera.kv.spawnflags = 56
		DispatchSpawn( camera )
		player.SetViewEntity( camera, true )
		cleanupData.camera = camera
		cleanupData.player = player
		if ( player.IsPlayer() ) // Check if the victim is an NPC
		Remote_CallFunction_NonReplay( player, "ServerCallback_HideHudForFPHackAnim" )
		thread CleanupForced1PSequenceAfterAnimDoneNoProxy( sequence, cleanupData )
	}
return cleanupData
}

void function CleanupForced1PSequenceAfterAnimDone( FirstPersonSequenceStruct sequence, entity player, entity other, Forced1PSequenceData cleanupData )
{
    player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnAnimationDone" )
    cleanupData.player.EndSignal( "OnDeath" ) // Use cleanupData.player so it stops when player dies
	cleanupData.player.EndSignal( "OnDestroy" )
	cleanupData.player.EndSignal( "OnAnimationDone" )
	OnThreadEnd( function() : ( cleanupData )
	{
		if ( IsValid( cleanupData.player ) && ( cleanupData.camera ) && cleanupData.player.IsPlayer() )
			CleanupForced1PSequence( cleanupData )
	})
	FirstPersonSequence( sequence, player, other )
}

void function CleanupForced1PSequenceAfterAnimDoneNoProxy( FirstPersonSequenceStruct sequence, Forced1PSequenceData cleanupData )
{
	WaittillAnimDone( cleanupData.player )
	if ( IsValid( cleanupData.player ) && ( cleanupData.camera ) && cleanupData.player.IsPlayer() )
	CleanupForced1PSequenceNoProxy( cleanupData )
}

void function CleanupForced1PSequence( Forced1PSequenceData cleanupData )
{
	cleanupData.player.Show()
	cleanupData.player.ClearViewEntity()
	cleanupData.camera.Destroy()
	cleanupData.ownerProxy.Destroy()
	cleanupData.thirdPersonProxy.Destroy()
}

void function CleanupForced1PSequenceNoProxy( Forced1PSequenceData cleanupData )
{
	cleanupData.player.ClearViewEntity()
	cleanupData.camera.Destroy()
}
#endif

#if CLIENT
void function ServerCallback_HideHudForFPHackAnim()
{
	// these functions just set hud positions to infront of/behind the camera, manually set them up here so they'll be far enough away so we don't see them in these anims
	// in an ideal world we wouldn't even have to turn off this rui stuff because it would be parented to our camera but unfortunately we do not live in an ideal world
	int ruiDrawIsEnabled = GetConVarInt( "rui_drawEnable" )
    GetLocalClientPlayer().ClientCommand( "rui_drawEnable 0" )
	//thread MainHud_TurnOff_RUI( true )
	//HidePermanentCockpitRui()
	//RuiTopology_UpdatePos( clGlobal.topoCockpitHud, < -1000, -1000, -1000 >, < -1000, -1000, -1000 >, < -1000, -1000, -1000 > )
	//RuiTopology_UpdatePos( clGlobal.topoCockpitHudPermanent, < -1000, -1000, -1000 >, < -1000, -1000, -1000 >, < -1000, -1000, -1000 > )
		
	thread EnableHudOnViewRestored( ruiDrawIsEnabled )
}

void function EnableHudOnViewRestored( int ruiDrawIsEnabled )
{
	while ( GetViewEntity() != GetLocalClientPlayer() )
		WaitFrame()
    GetLocalClientPlayer().ClientCommand( "rui_drawEnable " + ruiDrawIsEnabled )
	//thread MainHud_TurnOn_RUI( true )
	//ShowPermanentCockpitRui()
}
#endif