untyped

global function ClassicRodeo_InitPlaylistVars

#if SERVER
global function ClassicRodeo_SetRodeoAttackDamageScale

global function CreateClassicRodeoWeakpoint

// callbacks
global function AddCallback_ClassicRodeo_WeakpointTitanDamaged

// debug
const bool CLASSIC_RODEO_DEBUG = false
												
struct
{
	float classicRodeoAdditionalDamage = 1.5 // default additional damage value, should make it changable through playlistVars
	// callbacks
	array<void functionref( entity, var )> weakpointTitanDamagedCallbacks

	// in-file variable
	bool isWeakpointDamage // for OnWeakpointAttachedTitanDamaged() handle damage
} file
#endif


const asset RODEO_WEAKPOINT_HITBOX_MODEL = $"models/weapons/bullets/triple_threat_projectile.mdl" // $"models/Weapons/ammoboxes/backpack_single.mdl" // this one's too big, will block many damages

void function ClassicRodeo_InitPlaylistVars()
{
	AddPrivateMatchModeSettingEnum( "#MODE_SETTING_CATEGORY_TITAN", "classic_rodeo", [ "#SETTING_DISABLED", "#SETTING_ENABLED" ], "0" )
#if SERVER
	PrecacheModel( RODEO_WEAKPOINT_HITBOX_MODEL )
#endif
}

#if SERVER
void function ClassicRodeo_SetRodeoAttackDamageScale( float scale )
{
	file.classicRodeoAdditionalDamage = scale
}

// UTILITY
entity function CreateClassicRodeoWeakpoint( entity player, entity titan )
{
	entity weakpoint = CreatePropScript( RODEO_WEAKPOINT_HITBOX_MODEL )// 
	weakpoint.SetParent( titan, "RODEO_BATTERY" )
	weakpoint.SetLocalOrigin( < 0, -4, 0 > ) // < 0, 0, 0 > for ammobox
	weakpoint.SetLocalAngles( < 90, -90, 0 > )
	weakpoint.SetTakeDamageType( DAMAGE_YES )

	// setup
	SetTeam( weakpoint, TEAM_UNASSIGNED )
	SetVisibleEntitiesInConeQueriableEnabled( weakpoint, true ) // allow shotgun pellets to find it
	SetObjectCanBeMeleed( weakpoint, false )
	weakpoint.SetPassThroughThickness( 1024 ) // almost prevent every weapon from passing through
	
	weakpoint.kv.solid = SOLID_HITBOXES
	weakpoint.Hide()

	// setup health, avoid it sometimes disappear once and make player unable to land shots
	weakpoint.SetMaxHealth( 10000 )
	weakpoint.SetHealth( 10000 )

	// set armor type correctly so we don't need to figure out damage
	weakpoint.SetArmorType( ARMOR_TYPE_HEAVY )
	SetCustomSmartAmmoTarget( weakpoint, false )

	// debug	
	#if CLASSIC_RODEO_DEBUG
		weakpoint.Show()
	#endif // CLASSIC_RODEO_DEBUG

	entity titanSoul = titan.GetTitanSoul()
	// tweak on weakpoint position
	switch ( GetSoulTitanSubClass( titanSoul ) )
	{
		case "stryder":
			weakpoint.SetLocalOrigin( < 0, -4, -2 > ) // < 0, 4, -4 > for ammobox
			break
		case "ogre":
			weakpoint.SetLocalOrigin( < 0, -7, 0 > )
			break
	}
	
	weakpoint.s.pilot <- player
	weakpoint.s.titanSoul <- titanSoul
	
	AddEntityCallback_OnPostDamaged( weakpoint, OnRodeoWeakpointPostDamaged )
	thread HandleWeakpointAttachedTitanDamage( weakpoint, titan )

	return weakpoint
}

void function OnRodeoWeakpointPostDamaged( entity weakpoint, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( IsValid( attacker ) && attacker == weakpoint.s.pilot )
	{
		entity titanSoul = attacker.GetTitanSoulBeingRodeoed()
		if ( IsValid( titanSoul ) && titanSoul == weakpoint.s.titanSoul )
		{
			entity titan = titanSoul.GetTitan() // real titan
			if( IsValid( titan ) )
			{
				int rodeoDamage = DamageInfo_GetDamage( damageInfo ) * file.classicRodeoAdditionalDamage
				int damageTypes = DamageInfo_GetCustomDamageType( damageInfo ) | DF_BYPASS_SHIELD | DF_CRITICAL
				
				file.isWeakpointDamage = true // mark as this will be weak point damage
				titan.TakeDamage( rodeoDamage, attacker, attacker, { damageSourceId = eDamageSourceId.rodeo, scriptType = damageTypes } )
				file.isWeakpointDamage = false // clean up
			}
		}
	}
	
	DamageInfo_SetDamage( damageInfo, 0 ) // make sure weakpoint ent doesn't die ever
}

void function AddCallback_ClassicRodeo_WeakpointDamaged( void functionref( entity, var, RodeoWeakpointDamage ) callbackFunc )
{
	if ( !file.weakpointDamagedCallbacks.contains( callbackFunc ) )
		file.weakpointDamagedCallbacks.append( callbackFunc )
}

// handle attached titan damage
void function HandleWeakpointAttachedTitanDamage( entity weakpoint, entity titan )
{
	titan.EndSignal( "OnDestroy" )
	AddEntityCallback_OnDamaged( titan, OnWeakpointAttachedTitanDamaged )

	weakpoint.WaitSignal( "OnDestroy" )
	RemoveEntityCallback_OnDamaged( titan, OnWeakpointAttachedTitanDamaged )
}

void function OnWeakpointAttachedTitanDamaged( entity titan, var damageInfo )
{
	// weakpoint damage mark!
	if ( !file.isWeakpointDamage ) // this isn't weakpoint damage
	{
		// debug
		#if CLASSIC_RODEO_DEBUG
			print( "Titan taking non-weakpoint damage!" )
		#endif
		return
	}

	// debug
	#if CLASSIC_RODEO_DEBUG
		print( "Titan weakpoint damaged!" )
	#endif

	// run modified callbacks
	foreach ( void functionref( entity, var ) callbackFunc in file.weakpointTitanDamagedCallbacks )
		callbackFunc( titan, damageInfo )
	//
}
#endif