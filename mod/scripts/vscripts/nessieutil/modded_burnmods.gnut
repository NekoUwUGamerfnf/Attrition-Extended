// note that this file is currently only for amped weapons burncard, can't affect CodeCallback_CheckPassThroughAddsMods()
global function Modded_Weapon_BurnMods_Init

// main callbacks
global function ModdedBurnMods_AddDisabledMod // weapon with these mods won't get a burnmod. mostly for CodeCallback_CheckPassThroughAddsMods()
global function ModdedBurnMods_AddReplacementBurnMod // use another mod to replace a weapon's burnmod

// utilities
global function ModdedBurnMods_IsModdedWeaponOrProjectile
global function ModdedBurnMods_WeaponOrProjectileHasReplacementBurnMod
global function ModdedBurnMods_WeaponOrProjectileHasDisabledBurnMod

global function ModdedBurnMods_GetBurnModFromWeaponOrProjectile // pass a weapon or projectile entity and get it's burnmod with modded support

struct
{
	array<string> moddedMods
	array<string> burnModDisabledMods
	table<string, string> replacementBurnMods
} file

void function Modded_Weapon_BurnMods_Init()
{

}

void function ModdedBurnMods_AddDisabledMod( string mod )
{
	if ( !file.burnModDisabledMods.contains( mod ) )
		file.burnModDisabledMods.append( mod )

	AddToTotalModdedMods( mod )
}

void function ModdedBurnMods_AddReplacementBurnMod( string mod, string replacement )
{
	if ( !( mod in file.replacementBurnMods ) )
		file.replacementBurnMods[ mod ] <- ""
	file.replacementBurnMods[ mod ] = replacement

	AddToTotalModdedMods( mod )
}

void function AddToTotalModdedMods( string mod )
{
	if ( !file.moddedMods.contains( mod ) )
		file.moddedMods.append( mod )
}

bool function ModdedBurnMods_IsModdedWeaponOrProjectile( entity weapon )
{
	array<string> mods = GetModsFromWeaponOrProjectile( weapon )

	foreach ( string mod in file.moddedMods )
	{
		if ( mods.contains( mod ) )
			return true
	}

	return false
}

string function ModdedBurnMods_GetBurnModFromWeaponOrProjectile( entity weapon )
{
	// generic checks
    if( !IsValid( weapon ) )
        return ""
	if ( !ModdedBurnMods_IsModdedWeaponOrProjectile( weapon ) )
		return ""
	if ( ModdedBurnMods_WeaponOrProjectileHasDisabledBurnMod( weapon ) )
		return ""

	array<string> mods = GetModsFromWeaponOrProjectile( weapon )

	foreach ( string mod in mods )
	{
		if ( mod in file.replacementBurnMods )
			return file.replacementBurnMods[ mod ]
	}

	// no any modded burnmod found
	return ""
}

bool function ModdedBurnMods_WeaponOrProjectileHasReplacementBurnMod( entity weapon )
{
	if ( ModdedBurnMods_WeaponOrProjectileHasDisabledBurnMod( weapon ) ) // shouldn't apply any burnmod for disabled weapon
		return false

	array<string> mods = GetModsFromWeaponOrProjectile( weapon )

    foreach ( string mod, string replace in file.replacementBurnMods )
	{
		if ( mods.contains( mod ) )
			return true
	}

	return false
}

bool function ModdedBurnMods_WeaponOrProjectileHasDisabledBurnMod( entity weapon )
{
	array<string> mods = GetModsFromWeaponOrProjectile( weapon )

	foreach ( string mod in file.burnModDisabledMods )
	{
		if ( mods.contains( mod ) )
			return true
	}

	return false
}

array<string> function GetModsFromWeaponOrProjectile( entity weaponOrProjectile )
{
	array<string> mods
	if ( weaponOrProjectile.IsProjectile() )
		mods = Vortex_GetRefiredProjectileMods( weaponOrProjectile ) // get mods with refire support
	else
		mods = weaponOrProjectile.GetMods()

	return mods
}